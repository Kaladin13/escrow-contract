#include "imports/stdlib.fc";
#include "ft/params.fc";
#include "ft/jetton-utils.fc";
#include "ft/op-codes.fc";

;; Escrow Smart Contract with TON/Jetton payments

{-

params: guarantor_address, deal_amount, guarantor_fee_percent, asset_address, seller_address

messages:
    buyer:
        - send funds
    guarantor:
        - accept
        - cancel
    anyone:
        - top up

flow:
seller::deploy -> buyer::send_funds -> guarantor::approve/cancel -> send funds to seller + royalties or refund

-}

const op::approve = "op::approve"c;
const op::cancel = "op::cancel"c; 
const op::buyer_transfer = "op::buyer_transfer"c;
const op::top_up = "op::top_up"c;

const royalties_constant = 1000; ;; for floating point royalties (up to 3 digits)
;; gas consumption constants
const int fee_per_jetton = 50000000; ;; 0.05 ton
const int send_fee = 15000000; ;; 0.015 TON

global int ctx_id; ;; for address salt
global slice seller_address;
global slice guarantor_address;
global int deal_amount;
global slice asset_address; ;; empty slice to represent ton, minter jetton address otherwise
global int guarantor_royalty_percent; ;; see calculate_gauarantor_royalty
global slice buyer_address; ;; initially null, set after funding
global int state; ;; 0 - init, 1 - funded
global cell jetton_wallet_code;

() load_data() impure {
    slice ds = get_data().begin_parse();

    ctx_id = ds~load_uint(32);
    seller_address = ds~load_msg_addr();
    guarantor_address = ds~load_msg_addr();
    deal_amount = ds~load_uint(64);

    cell asset = ds~load_maybe_ref();
    if (null?(asset)) {
        ;; construct empty slice
        asset_address = begin_cell().end_cell().begin_parse();
    } else {
        ;; set to minter jetton address
        slice parsed_asset = asset.begin_parse();
        asset_address = parsed_asset~load_msg_addr();
    }

    guarantor_royalty_percent = ds~load_uint(32);
    buyer_address = ds~load_msg_addr();
    state = ds~load_uint(2);
    jetton_wallet_code = ds~load_maybe_ref();
}

() save_data() impure inline {
    cell asset = null();
    
    if (~ slice_empty?(asset_address)) {
        asset = begin_cell().store_slice(asset_address).end_cell();
    }

    set_data(begin_cell()
                .store_uint(ctx_id, 32)
                .store_slice(seller_address)
                .store_slice(guarantor_address)
                .store_uint(deal_amount, 64)
                .store_maybe_ref(asset)
                .store_uint(guarantor_royalty_percent, 32)
                .store_slice(buyer_address)
                .store_uint(state, 2)
                .store_maybe_ref(jetton_wallet_code)
            .end_cell()
    );
}

int calculate_gauarantor_royalty() inline {
    ;; use royalties_constant (set to 1_000) to represent
    ;; floating point percents less than 1%
    ;; e.g. 0,05% actual royalty would be 50 in state_init
    return deal_amount / (100 * royalties_constant) * guarantor_royalty_percent;
}

() send_tokens(slice recipient, int amount, int mode) impure {
    slice escrow_jetton_wallet = calculate_user_jetton_wallet_address(my_address(), asset_address, jetton_wallet_code);

    send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(escrow_jetton_wallet) ;; recepient address
        .store_coins(fee_per_jetton)
        .store_uint(1, 107)
        .store_ref(begin_cell()
            .store_uint(op::transfer(), 32)
            .store_uint(0, 64) ;;query id
            .store_coins(amount)
            .store_slice(recipient)
            .store_slice(recipient)
            .store_uint(0, 1)
            .store_coins(0)
            .store_uint(0, 1)
            .end_cell())
        .end_cell(), mode);
}

() handle_approve_ton() impure {
    int royalty = calculate_gauarantor_royalty();

    [int balance, _] = get_balance();
    throw_unless(404, balance > (deal_amount + 2 * send_fee)); ;; check balance for both fees, so we don't abort after first

    cell msg = begin_cell()
                  .store_uint(0x10, 6) ;; no bouncable messages
                  .store_slice(seller_address)
                  .store_coins(deal_amount - royalty)
                  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .end_cell();

    send_raw_message(msg, 1); ;; pays transfer fees separetely

    cell royalty_msg = begin_cell()
                          .store_uint(0x10, 6) ;; no bouncable messages
                          .store_slice(guarantor_address)
                          .store_coins(0)
                          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                       .end_cell();

    send_raw_message(royalty_msg, 128 + 32); ;; send the remaining balance of contract
}

() handle_approve_jetton() impure {
    int royalty = calculate_gauarantor_royalty();

    [int balance, _] = get_balance();
    throw_unless(404, balance > (2 * fee_per_jetton));

    send_tokens(seller_address, deal_amount - royalty, 1);
    send_tokens(guarantor_address, royalty, 128 + 32);
}

() handle_cancell_ton() impure {
    ;; it's up to business logic whether guarantor should receive
    ;; royalty in case of cancelled deal, in this implementation he will not

    cell msg = begin_cell()
                    .store_uint(0x10, 6) ;; no bouncable messages
                    .store_slice(buyer_address)
                    .store_coins(0)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .end_cell();

    send_raw_message(msg, 128 + 32); ;; refund to buyer & send all remaining
}

() handle_cancell_jetton() impure {
    send_tokens(buyer_address, deal_amount, 128 + 32);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages

        return ();
    }

    slice sender_address = cs~load_msg_addr();
    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::buyer_transfer) {
        throw_unless(400, state == 0 | (~ slice_empty?(asset_address)));
        throw_unless(401, msg_value == deal_amount);

        state = 1;
        buyer_address = sender_address;
        save_data();

        return ();
    }

    if (op == op::transfer_notification()) {
        throw_unless(400, state == 0 | slice_empty?(asset_address));
        
        in_msg_body~load_uint(64); ;; skip query id
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        ;; verify escrow jetton wallet
        throw_unless(402,
            equal_slices(
                calculate_user_jetton_wallet_address(my_address(), asset_address, jetton_wallet_code), 
                sender_address
            )
        );

        throw_unless(401, jetton_amount == deal_amount);

        state = 1;
        buyer_address = from_address;
        save_data();

        return ();
    }

    if (op == op::approve) {
        throw_unless(403, state == 1 & equal_slices(sender_address, guarantor_address));

        ;; send funds to seller, royalties to guarantor
        if (slice_empty?(asset_address)) {
            handle_approve_ton();
        } else {
            handle_approve_jetton();
        }

        return ();
    }

    if (op == op::cancel) {
        throw_unless(403, state == 1 & equal_slices(sender_address, guarantor_address));

        ;; refund buyer
        if (slice_empty?(asset_address)) {
            handle_cancell_ton();
        } else {
            handle_cancell_jetton();
        }

        return ();
    }

    if (op == op::top_up) {
        return ();
    }

    throw(0xffff);
}

int get_state() method_id {
    load_data();
    return state;
}

int get_guarator_royalty() method_id {
    load_data();
    return calculate_gauarantor_royalty();
}

(int, slice, slice, int, slice, int, slice, int, cell) get_escrow_data() method_id {
    load_data();

    return (
        ctx_id,
        seller_address,
        guarantor_address,
        deal_amount,
        asset_address,
        guarantor_royalty_percent,
        buyer_address,
        state,
        jetton_wallet_code
    );
}